import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:printing/printing.dart';
import 'package:image/image.dart' as img;

import 'package:barcode/barcode.dart' as BAR;
import 'dart:ui' as ui;
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:try_sod/gen_pdf.dart';

Future<List<int>> pdf_to_img() async {
  // final pdf = await gen_pdf(context, data, copy);
  // print("HII");
  List<int> byte = [];
  try {
    final img.Image? pageImage = await pdfToImage(await gen_pdf(), 0);

    if (pageImage != null) {
      final profile = await CapabilityProfile.load();
      final generator = Generator(PaperSize.mm58, profile);

      try {
        return
            //generator.text('Bold text', styles: PosStyles(bold: true));

            generator.image(pageImage, align: PosAlign.left) +
                generator.cut() +
                generator.drawer();
      } catch (e) {
        print(e);
      }
    }
  } catch (e) {
    print("Error generating PDF or printing bytes: ${e.toString()}");
    return []; // Return an empty list on error
  }

  return byte; // Return the generated byte list
}

Future<List<int>> pdf_img_sticker() async {
  List<int> byte = [];

  try {
    // Convert PDF page to an image
    final img.Image? pageImage = await pdfToImage(await gen_pdf(), 0);

    final img.Image resizedImage =
        img.copyCrop(pageImage!, x: 0, y: 0, width: 632, height: 464);

    List<int> ffList = [];
    int byteAccumulator = 0; // Accumulates bits to form a byte
    int bitCount = 0; // Tracks the number of bits in the current byte

    // Process the resized image into black-and-white pixels
    for (int y = 0; y < resizedImage!.height; y++) {
      for (int x = 0; x < resizedImage.width; x++) {
        final pixel = resizedImage.getPixel(x, y);

        // Check if the alpha channel is 0 (fully transparent)
        int bwValue;
        if (pixel.a == 0) {
          bwValue = 1; // Treat fully transparent pixels as white
        } else {
          // Calculate luminance for non-transparent pixels
          int gray = img.getLuminanceRgb(pixel.r, pixel.g, pixel.b).toInt();
          bwValue = gray > 128 ? 1 : 0; // Threshold to black or white
        }

        // Shift bwValue to the appropriate position in the byte and add it
        byteAccumulator = (byteAccumulator << 1) | bwValue;
        bitCount++;

        // Once we accumulate 8 bits, convert to byte and reset counters
        if (bitCount == 8) {
          ffList.add(byteAccumulator);
          byteAccumulator = 0;
          bitCount = 0;
        }
      }
    }
    // Append header bytes
    byte.addAll([
      0x53, 0x49, 0x5A, 0x45, 0x20, 0x35, 0x35, 0x20, 0x6D, 0x6D, //
      0x2C, 0x34, 0x30, 0x20, 0x6D, 0x6D, 0x0D, 0x0A, 0x47, 0x41, //
      0x50, 0x20, 0x32, 0x2C, 0x30, 0x6D, 0x6D, 0x0D, 0x0A, 0x43, //
      0x4C, 0x53, 0x0D, 0x0A
    ]);

/*
SIZE 40 mm,20 mm
GAP 2,0mm
CLS

*/
    // Append additional command bytes
    byte.addAll([
      0x42, 0x49, 0x54, 0x4D, 0x41, 0x50, 0x20, 0x30, 0x2C, 0x30, 0x2C,
      0x37, 0x39, 0x2C, // 79 dot
      0x34, 0x36, 0x34, // "632" 464 bytes
      0x2C, 0x30, 0x2C
    ]);

    // Append pixel data
    byte.addAll(ffList);
    byte.addAll([0x0d, 0x0a]);

    // Append final print command
    byte.addAll([
      0x50,
      0x52,
      0x49,
      0x4E,
      0x54,
      0x20,
      0x31, //31
      0x2C,
      0x31,
      0x0D,
      0x0A,
    ]);

    return byte; // Return the byte array for printing
  } catch (e) {
    print("Error generating PDF or printing bytes: ${e.toString()}");
    return []; // Return an empty list on error
  }
}

Future<img.Image?> pdfToImage(Uint8List pdfBytes, int pageIndex) async {
  return img.decodePng(
      await (await Printing.raster(pdfBytes, pages: [pageIndex]).first)
          .toPng());
}

// Future<int> LENGHT_DATA_THAI(String DATA) async {
//   int L = DATA.length;
//   int out_L = L;

//   for (int i = 0; i < L; i++) {
//     if (DATA[i] == "่") {
//       //ไม่เอก

//       out_L--;
//     } else if (DATA[i] == "้") {
//       //ไม่โท

//       out_L--;
//     } else if (DATA[i] == "๊") {
//       //ไม่ตรี

//       out_L--;
//     } else if (DATA[i] == "๋") {
//       //ไม่จัตวา

//       out_L--;
//     } else if (DATA[i] == "ุ") {
// // สระระอุ
//       out_L--;
//     } else if (DATA[i] == "ู") {
// // สระระอู

//       out_L--;
//     } else if (DATA[i] == "ั") {
// //  ไม่หันะกาท

//       out_L--;
//     } else if (DATA[i] == "ิ") {
//       // ิ

//       out_L--;
//     } else if (DATA[i] == "ี") {
//       // ี

//       out_L--;
//     } else if (DATA[i] == "ื") {
//       //  ื

//       out_L--;
//     } else if (DATA[i] == "ึ") {
//       //  ึ

//       out_L--;
//     } else if (DATA[i] == "็") {
//       //  ็

//       out_L--;
//     }
//   }

//   return out_L;
// }

// int LENGHT_THAI(String DATA) {
//   int L = DATA.length;
//   int out_L = L;

//   for (int i = 0; i < L; i++) {
//     if (DATA[i] == "่") {
//       //ไม่เอก

//       out_L--;
//     } else if (DATA[i] == "้") {
//       //ไม่โท

//       out_L--;
//     } else if (DATA[i] == "๊") {
//       //ไม่ตรี

//       out_L--;
//     } else if (DATA[i] == "๋") {
//       //ไม่จัตวา

//       out_L--;
//     } else if (DATA[i] == "ุ") {
// // สระระอุ
//       out_L--;
//     } else if (DATA[i] == "ู") {
// // สระระอู

//       out_L--;
//     } else if (DATA[i] == "ั") {
// //  ไม่หันะกาท

//       out_L--;
//     } else if (DATA[i] == "ิ") {
//       // ิ

//       out_L--;
//     } else if (DATA[i] == "ี") {
//       // ี

//       out_L--;
//     } else if (DATA[i] == "ื") {
//       //  ื

//       out_L--;
//     } else if (DATA[i] == "ึ") {
//       //  ึ

//       out_L--;
//     } else if (DATA[i] == "็") {
//       //  ็

//       out_L--;
//     }
//   }

//   return out_L;
// }

Future<Uint8List> buildBarcode(BAR.Barcode bc, String data, String type,
    {String? filename,
    double? width,
    double? height,
    double? fontHeight}) async {
  // Create the Barcode
  final svg;

  if (type == "QRCODE") {
    svg = bc.toSvg(
      data,
      width: 120,
      height: 120,
      fontHeight: fontHeight,
    );
    Uint8List? imageData = await svgToUint8List(svg, 120, 120);

    // Check if the conversion was successful
    if (imageData != null) {
      return imageData;
    } else {
      throw Exception('Failed to convert SVG to Uint8List');
    }
  } else {
    svg = bc.toSvg(
      data,
      width: 200,
      height: 80,
      fontHeight: fontHeight,
    );
    Uint8List? imageData = await svgToUint8List(svg, 200, 80);

    // Check if the conversion was successful
    if (imageData != null) {
      return imageData;
    } else {
      throw Exception('Failed to convert SVG to Uint8List');
    }
  }

  // Convert the SVG to Uint8List
}

Future<Uint8List?> svgToUint8List(String rawSvg, int width, int height) async {
  try {
    // Load the SVG
    final svgLoader = SvgStringLoader(rawSvg);

    final pictureInfo = await vg.loadPicture(svgLoader, null);
    // Convert the picture to an image
    final ui.Image image = await pictureInfo.picture.toImage(width, height);
    // Convert the image to PNG ByteData
    final ByteData? byteData =
        await image.toByteData(format: ui.ImageByteFormat.png);
    // Dispose of the picture to free resources
    pictureInfo.picture.dispose();
    // Return the Uint8List if conversion was successful
    return byteData?.buffer.asUint8List();
  } catch (e) {
    print("Error converting SVG to Uint8List: $e");
    return null;
  }
}
